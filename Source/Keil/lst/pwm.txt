; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\pwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pwm.d --feedback=.\obj\template.fed --cpu=Cortex-M0 --apcs=interwork -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\Mini51Series\Include -I..\Library\StdDriver\inc -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include --omf_browse=.\obj\pwm.crf ..\Library\StdDriver\src\pwm.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  PWM_ConfigOutputChannel PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  b5ff              PUSH     {r0-r7,lr}
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  4839              LDR      r0,|L1.232|
000004  b083              SUB      sp,sp,#0xc            ;40
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  461d              MOV      r5,r3                 ;40
00000a  4611              MOV      r1,r2
00000c  9001              STR      r0,[sp,#4]
00000e  f7fffffe          BL       __aeabi_uidivmod
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  2601              MOVS     r6,#1
;;;43         uint16_t u16CNR = 0xFFFF;
000014  4c35              LDR      r4,|L1.236|
000016  27ff              MOVS     r7,#0xff              ;42
000018  9000              STR      r0,[sp,#0]
                  |L1.26|
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
00001a  4631              MOV      r1,r6
00001c  9800              LDR      r0,[sp,#0]
00001e  f7fffffe          BL       __aeabi_uidivmod
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
000022  2101              MOVS     r1,#1
000024  0609              LSLS     r1,r1,#24
000026  4288              CMP      r0,r1
000028  d812              BHI      |L1.80|
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
00002a  1901              ADDS     r1,r0,r4
00002c  0209              LSLS     r1,r1,#8
00002e  0e0f              LSRS     r7,r1,#24
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
000030  2f03              CMP      r7,#3
000032  d200              BCS      |L1.54|
;;;56                 u8Prescale = 2;
000034  2702              MOVS     r7,#2
                  |L1.54|
;;;57     
;;;58             i /= u8Prescale;
000036  4639              MOV      r1,r7
000038  f7fffffe          BL       __aeabi_uidivmod
;;;59     
;;;60             if(i <= 0x10000) {
00003c  2101              MOVS     r1,#1
00003e  0409              LSLS     r1,r1,#16
000040  4288              CMP      r0,r1
000042  d805              BHI      |L1.80|
;;;61                 if(i == 1)
000044  2801              CMP      r0,#1
000046  d001              BEQ      |L1.76|
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
000048  b284              UXTH     r4,r0
00004a  e005              B        |L1.88|
                  |L1.76|
00004c  2401              MOVS     r4,#1                 ;62
00004e  e003              B        |L1.88|
                  |L1.80|
000050  0670              LSLS     r0,r6,#25             ;45
000052  0e06              LSRS     r6,r0,#24             ;45
000054  2e11              CMP      r6,#0x11              ;45
000056  d3e0              BCC      |L1.26|
                  |L1.88|
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
000058  4639              MOV      r1,r7
00005a  4371              MULS     r1,r6,r1
00005c  4361              MULS     r1,r4,r1
00005e  9801              LDR      r0,[sp,#4]
000060  f7fffffe          BL       __aeabi_uidivmod
;;;71     
;;;72         u8Prescale -= 1;
000064  1e7f              SUBS     r7,r7,#1
;;;73         u16CNR -= 1;
000066  1e64              SUBS     r4,r4,#1
000068  b2fb              UXTB     r3,r7                 ;72
00006a  b2a4              UXTH     r4,r4
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
00006c  9000              STR      r0,[sp,#0]
00006e  2e01              CMP      r6,#1
000070  d030              BEQ      |L1.212|
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
000072  2e02              CMP      r6,#2
000074  d030              BEQ      |L1.216|
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
000076  2e04              CMP      r6,#4
000078  d030              BEQ      |L1.220|
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
00007a  2e08              CMP      r6,#8
00007c  d030              BEQ      |L1.224|
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
00007e  2103              MOVS     r1,#3
                  |L1.128|
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
000080  4a1b              LDR      r2,|L1.240|
000082  6816              LDR      r6,[r2,#0]
000084  9804              LDR      r0,[sp,#0x10]
000086  27ff              MOVS     r7,#0xff
000088  0840              LSRS     r0,r0,#1
00008a  00c0              LSLS     r0,r0,#3
00008c  4087              LSLS     r7,r7,r0
00008e  43be              BICS     r6,r6,r7
000090  4083              LSLS     r3,r3,r0
000092  431e              ORRS     r6,r6,r3
000094  6016              STR      r6,[r2,#0]
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
000096  6853              LDR      r3,[r2,#4]
000098  9804              LDR      r0,[sp,#0x10]
00009a  2607              MOVS     r6,#7
00009c  0080              LSLS     r0,r0,#2
00009e  4086              LSLS     r6,r6,r0
0000a0  43b3              BICS     r3,r3,r6
0000a2  4081              LSLS     r1,r1,r0
0000a4  430b              ORRS     r3,r3,r1
0000a6  6053              STR      r3,[r2,#4]
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
0000a8  6891              LDR      r1,[r2,#8]
0000aa  2308              MOVS     r3,#8
0000ac  0049              LSLS     r1,r1,#1
0000ae  0849              LSRS     r1,r1,#1
0000b0  4083              LSLS     r3,r3,r0
0000b2  4319              ORRS     r1,r1,r3
0000b4  6091              STR      r1,[r2,#8]
0000b6  4611              MOV      r1,r2                 ;87
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
0000b8  1846              ADDS     r6,r0,r1
0000ba  2d00              CMP      r5,#0                 ;90
0000bc  d012              BEQ      |L1.228|
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
0000be  1c60              ADDS     r0,r4,#1
0000c0  4368              MULS     r0,r5,r0
0000c2  2164              MOVS     r1,#0x64
0000c4  f7fffffe          BL       __aeabi_uidivmod
0000c8  1e40              SUBS     r0,r0,#1
                  |L1.202|
0000ca  6270              STR      r0,[r6,#0x24]
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
0000cc  60f4              STR      r4,[r6,#0xc]
;;;95     
;;;96         return(i);
0000ce  9800              LDR      r0,[sp,#0]
;;;97     }
0000d0  b007              ADD      sp,sp,#0x1c
0000d2  bdf0              POP      {r4-r7,pc}
                  |L1.212|
0000d4  2104              MOVS     r1,#4                 ;76
0000d6  e7d3              B        |L1.128|
                  |L1.216|
0000d8  2100              MOVS     r1,#0                 ;78
0000da  e7d1              B        |L1.128|
                  |L1.220|
0000dc  2101              MOVS     r1,#1                 ;80
0000de  e7cf              B        |L1.128|
                  |L1.224|
0000e0  2102              MOVS     r1,#2                 ;82
0000e2  e7cd              B        |L1.128|
                  |L1.228|
0000e4  2000              MOVS     r0,#0                 ;91
0000e6  e7f0              B        |L1.202|
;;;98     
                          ENDP

                  |L1.232|
                          DCD      SystemCoreClock
                  |L1.236|
                          DCD      0x0000ffff
                  |L1.240|
                          DCD      0x40040000

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.2||, ||.text||
                  PWM_Start PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  b530              PUSH     {r4,r5,lr}
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  2200              MOVS     r2,#0
000004  4610              MOV      r0,r2                 ;40
000006  2401              MOVS     r4,#1
                  |L2.8|
000008  4623              MOV      r3,r4                 ;40
00000a  4083              LSLS     r3,r3,r0
00000c  420b              TST      r3,r1
00000e  d003              BEQ      |L2.24|
000010  0085              LSLS     r5,r0,#2
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  4623              MOV      r3,r4
;;;43         uint16_t u16CNR = 0xFFFF;
000014  40ab              LSLS     r3,r3,r5
000016  431a              ORRS     r2,r2,r3              ;42
                  |L2.24|
000018  1c40              ADDS     r0,r0,#1
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
00001a  2806              CMP      r0,#6
00001c  d3f4              BCC      |L2.8|
00001e  4902              LDR      r1,|L2.40|
000020  6888              LDR      r0,[r1,#8]
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
000022  4310              ORRS     r0,r0,r2
000024  6088              STR      r0,[r1,#8]
000026  bd30              POP      {r4,r5,pc}
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L2.40|
                          DCD      0x40040000

                          AREA ||area_number.3||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.3||, ||.text||
                  PWM_Stop PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  b530              PUSH     {r4,r5,lr}
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  2000              MOVS     r0,#0
000004  4c06              LDR      r4,|L3.32|
000006  2501              MOVS     r5,#1
000008  4603              MOV      r3,r0                 ;40
                  |L3.10|
00000a  462a              MOV      r2,r5
00000c  4082              LSLS     r2,r2,r0
00000e  420a              TST      r2,r1
000010  d002              BEQ      |L3.24|
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  0082              LSLS     r2,r0,#2
;;;43         uint16_t u16CNR = 0xFFFF;
000014  1912              ADDS     r2,r2,r4
000016  60d3              STR      r3,[r2,#0xc]          ;42
                  |L3.24|
000018  1c40              ADDS     r0,r0,#1
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
00001a  2806              CMP      r0,#6
00001c  d3f5              BCC      |L3.10|
00001e  bd30              POP      {r4,r5,pc}
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L3.32|
                          DCD      0x40040000

                          AREA ||area_number.4||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.4||, ||.text||
                  PWM_ForceStop PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  b530              PUSH     {r4,r5,lr}
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  2200              MOVS     r2,#0
000004  4610              MOV      r0,r2                 ;40
000006  2401              MOVS     r4,#1
                  |L4.8|
000008  4623              MOV      r3,r4                 ;40
00000a  4083              LSLS     r3,r3,r0
00000c  420b              TST      r3,r1
00000e  d003              BEQ      |L4.24|
000010  0085              LSLS     r5,r0,#2
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  4623              MOV      r3,r4
;;;43         uint16_t u16CNR = 0xFFFF;
000014  40ab              LSLS     r3,r3,r5
000016  431a              ORRS     r2,r2,r3              ;42
                  |L4.24|
000018  1c40              ADDS     r0,r0,#1
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
00001a  2806              CMP      r0,#6
00001c  d3f4              BCC      |L4.8|
00001e  4902              LDR      r1,|L4.40|
000020  6888              LDR      r0,[r1,#8]
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
000022  4390              BICS     r0,r0,r2
000024  6088              STR      r0,[r1,#8]
000026  bd30              POP      {r4,r5,pc}
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L4.40|
                          DCD      0x40040000

                          AREA ||area_number.5||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.text||
                  PWM_EnableADCTrigger PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  b510              PUSH     {r4,lr}
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  4c0a              LDR      r4,|L5.44|
000004  230f              MOVS     r3,#0xf               ;40
000006  00c8              LSLS     r0,r1,#3
000008  2904              CMP      r1,#4                 ;40
00000a  d206              BCS      |L5.26|
00000c  6aa1              LDR      r1,[r4,#0x28]
00000e  4083              LSLS     r3,r3,r0
000010  4399              BICS     r1,r1,r3
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  4082              LSLS     r2,r2,r0
;;;43         uint16_t u16CNR = 0xFFFF;
000014  4311              ORRS     r1,r1,r2
000016  62a1              STR      r1,[r4,#0x28]         ;42
000018  bd10              POP      {r4,pc}
                  |L5.26|
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
00001a  3820              SUBS     r0,r0,#0x20
00001c  6ae1              LDR      r1,[r4,#0x2c]
00001e  4083              LSLS     r3,r3,r0
000020  4399              BICS     r1,r1,r3
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
000022  4082              LSLS     r2,r2,r0
000024  4311              ORRS     r1,r1,r2
000026  62e1              STR      r1,[r4,#0x2c]
000028  bd10              POP      {r4,pc}
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      0x40040040

                          AREA ||area_number.6||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.text||
                  PWM_DisableADCTrigger PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4a07              LDR      r2,|L6.32|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  00c8              LSLS     r0,r1,#3
000004  230f              MOVS     r3,#0xf               ;40
000006  2904              CMP      r1,#4
000008  d204              BCS      |L6.20|
00000a  6a91              LDR      r1,[r2,#0x28]
00000c  4083              LSLS     r3,r3,r0
00000e  4399              BICS     r1,r1,r3
000010  6291              STR      r1,[r2,#0x28]
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  4770              BX       lr
                  |L6.20|
;;;43         uint16_t u16CNR = 0xFFFF;
000014  3820              SUBS     r0,r0,#0x20
000016  4083              LSLS     r3,r3,r0              ;42
000018  6ad0              LDR      r0,[r2,#0x2c]
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
00001a  4398              BICS     r0,r0,r3
00001c  62d0              STR      r0,[r2,#0x2c]
00001e  4770              BX       lr
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L6.32|
                          DCD      0x40040040

                          AREA ||area_number.7||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.text||
                  PWM_ClearADCTriggerFlag PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4b07              LDR      r3,|L7.32|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  00c8              LSLS     r0,r1,#3
000004  2904              CMP      r1,#4                 ;40
000006  d204              BCS      |L7.18|
000008  6b19              LDR      r1,[r3,#0x30]         ;40
00000a  4082              LSLS     r2,r2,r0
00000c  4311              ORRS     r1,r1,r2
00000e  6319              STR      r1,[r3,#0x30]
000010  4770              BX       lr
                  |L7.18|
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  3820              SUBS     r0,r0,#0x20
;;;43         uint16_t u16CNR = 0xFFFF;
000014  4082              LSLS     r2,r2,r0
000016  6b58              LDR      r0,[r3,#0x34]         ;42
000018  4302              ORRS     r2,r2,r0
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
00001a  635a              STR      r2,[r3,#0x34]
00001c  4770              BX       lr
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      0x40040040

                          AREA ||area_number.8||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.text||
                  PWM_GetADCTriggerFlag PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4805              LDR      r0,|L8.24|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  00ca              LSLS     r2,r1,#3
000004  2904              CMP      r1,#4                 ;40
000006  d201              BCS      |L8.12|
000008  6b00              LDR      r0,[r0,#0x30]         ;40
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  6b40              LDR      r0,[r0,#0x34]
00000e  3a20              SUBS     r2,r2,#0x20
                  |L8.16|
000010  40d0              LSRS     r0,r0,r2
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  0700              LSLS     r0,r0,#28
;;;43         uint16_t u16CNR = 0xFFFF;
000014  0f00              LSRS     r0,r0,#28
000016  4770              BX       lr                    ;42
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L8.24|
                          DCD      0x40040040

                          AREA ||area_number.9||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.text||
                  PWM_EnableFaultBrake PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  0610              LSLS     r0,r2,#24
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  4902              LDR      r1,|L9.12|
000004  4318              ORRS     r0,r0,r3              ;40
000006  6208              STR      r0,[r1,#0x20]
000008  4770              BX       lr                    ;40
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0x40040040

                          AREA ||area_number.10||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.text||
                  PWM_ClearFaultBrakeFlag PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4901              LDR      r1,|L10.8|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  2080              MOVS     r0,#0x80
000004  6208              STR      r0,[r1,#0x20]         ;40
000006  4770              BX       lr
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L10.8|
                          DCD      0x40040040

                          AREA ||area_number.11||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.text||
                  PWM_EnableOutput PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4802              LDR      r0,|L11.12|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  69c2              LDR      r2,[r0,#0x1c]
000004  430a              ORRS     r2,r2,r1              ;40
000006  61c2              STR      r2,[r0,#0x1c]
000008  4770              BX       lr                    ;40
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0x40040040

                          AREA ||area_number.12||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.text||
                  PWM_DisableOutput PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4802              LDR      r0,|L12.12|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  69c2              LDR      r2,[r0,#0x1c]
000004  438a              BICS     r2,r2,r1              ;40
000006  61c2              STR      r2,[r0,#0x1c]
000008  4770              BX       lr                    ;40
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      0x40040040

                          AREA ||area_number.13||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.text||
                  PWM_EnableDeadZone PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  b530              PUSH     {r4,r5,lr}
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  4c08              LDR      r4,|L13.36|
000004  0848              LSRS     r0,r1,#1              ;40
000006  6a63              LDR      r3,[r4,#0x24]
000008  00c1              LSLS     r1,r0,#3              ;40
00000a  25ff              MOVS     r5,#0xff
00000c  408d              LSLS     r5,r5,r1
00000e  43ab              BICS     r3,r3,r5
000010  408a              LSLS     r2,r2,r1
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  4313              ORRS     r3,r3,r2
;;;43         uint16_t u16CNR = 0xFFFF;
000014  6263              STR      r3,[r4,#0x24]
000016  0323              LSLS     r3,r4,#12             ;42
000018  689a              LDR      r2,[r3,#8]
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
00001a  0199              LSLS     r1,r3,#6
00001c  4081              LSLS     r1,r1,r0
00001e  430a              ORRS     r2,r2,r1
000020  609a              STR      r2,[r3,#8]
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
000022  bd30              POP      {r4,r5,pc}
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L13.36|
                          DCD      0x40040040

                          AREA ||area_number.14||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.text||
                  PWM_DisableDeadZone PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  0848              LSRS     r0,r1,#1
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  4903              LDR      r1,|L14.16|
000004  688a              LDR      r2,[r1,#8]            ;40
000006  018b              LSLS     r3,r1,#6
000008  4083              LSLS     r3,r3,r0              ;40
00000a  439a              BICS     r2,r2,r3
00000c  608a              STR      r2,[r1,#8]
00000e  4770              BX       lr
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L14.16|
                          DCD      0x40040000

                          AREA ||area_number.15||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.text||
                  PWM_EnableDutyInt PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4803              LDR      r0,|L15.16|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  6942              LDR      r2,[r0,#0x14]
000004  1583              ASRS     r3,r0,#22             ;40
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3              ;40
00000a  6142              STR      r2,[r0,#0x14]
00000c  4770              BX       lr
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

00000e  0000              DCW      0x0000
                  |L15.16|
                          DCD      0x40040040

                          AREA ||area_number.16||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.text||
                  PWM_DisableDutyInt PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4803              LDR      r0,|L16.16|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  6942              LDR      r2,[r0,#0x14]
000004  1583              ASRS     r3,r0,#22             ;40
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3              ;40
00000a  6142              STR      r2,[r0,#0x14]
00000c  4770              BX       lr
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x40040040

                          AREA ||area_number.17||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.text||
                  PWM_ClearDutyIntFlag PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  20ff              MOVS     r0,#0xff
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  3001              ADDS     r0,#1
000004  4088              LSLS     r0,r0,r1              ;40
000006  4901              LDR      r1,|L17.12|
000008  6188              STR      r0,[r1,#0x18]         ;40
00000a  4770              BX       lr
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L17.12|
                          DCD      0x40040040

                          AREA ||area_number.18||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.text||
                  PWM_GetDutyIntFlag PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4804              LDR      r0,|L18.20|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  6980              LDR      r0,[r0,#0x18]
000004  22ff              MOVS     r2,#0xff              ;40
000006  3201              ADDS     r2,#1
000008  408a              LSLS     r2,r2,r1              ;40
00000a  4010              ANDS     r0,r0,r2
00000c  d000              BEQ      |L18.16|
00000e  2001              MOVS     r0,#1
                  |L18.16|
000010  4770              BX       lr
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

000012  0000              DCW      0x0000
                  |L18.20|
                          DCD      0x40040040

                          AREA ||area_number.19||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.text||
                  PWM_EnableFaultBrakeInt PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4803              LDR      r0,|L19.16|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  6941              LDR      r1,[r0,#0x14]
000004  2201              MOVS     r2,#1                 ;40
000006  0412              LSLS     r2,r2,#16
000008  4311              ORRS     r1,r1,r2              ;40
00000a  6141              STR      r1,[r0,#0x14]
00000c  4770              BX       lr
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

00000e  0000              DCW      0x0000
                  |L19.16|
                          DCD      0x40040040

                          AREA ||area_number.20||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.text||
                  PWM_DisableFaultBrakeInt PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4803              LDR      r0,|L20.16|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  6941              LDR      r1,[r0,#0x14]
000004  2201              MOVS     r2,#1                 ;40
000006  0412              LSLS     r2,r2,#16
000008  4391              BICS     r1,r1,r2              ;40
00000a  6141              STR      r1,[r0,#0x14]
00000c  4770              BX       lr
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

00000e  0000              DCW      0x0000
                  |L20.16|
                          DCD      0x40040040

                          AREA ||area_number.21||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.text||
                  PWM_ClearFaultBrakeIntFlag PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4801              LDR      r0,|L21.8|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  6181              STR      r1,[r0,#0x18]
000004  4770              BX       lr                    ;40
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      0x40040040

                          AREA ||area_number.22||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.text||
                  PWM_GetFaultBrakeIntFlag PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4802              LDR      r0,|L22.12|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  6980              LDR      r0,[r0,#0x18]
000004  4008              ANDS     r0,r0,r1              ;40
000006  d000              BEQ      |L22.10|
000008  2001              MOVS     r0,#1                 ;40
                  |L22.10|
00000a  4770              BX       lr
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L22.12|
                          DCD      0x40040040

                          AREA ||area_number.23||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.text||
                  PWM_EnablePeriodInt PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  b510              PUSH     {r4,lr}
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  4c05              LDR      r4,|L23.24|
000004  6960              LDR      r0,[r4,#0x14]         ;40
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17             ;40
00000a  4398              BICS     r0,r0,r3
00000c  2301              MOVS     r3,#1
00000e  408b              LSLS     r3,r3,r1
000010  4318              ORRS     r0,r0,r3
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  4310              ORRS     r0,r0,r2
;;;43         uint16_t u16CNR = 0xFFFF;
000014  6160              STR      r0,[r4,#0x14]
000016  bd10              POP      {r4,pc}               ;42
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L23.24|
                          DCD      0x40040040

                          AREA ||area_number.24||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.text||
                  PWM_DisablePeriodInt PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4803              LDR      r0,|L24.16|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  6942              LDR      r2,[r0,#0x14]
000004  2301              MOVS     r3,#1                 ;40
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3              ;40
00000a  6142              STR      r2,[r0,#0x14]
00000c  4770              BX       lr
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      0x40040040

                          AREA ||area_number.25||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.text||
                  PWM_ClearPeriodIntFlag PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  2001              MOVS     r0,#1
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  4088              LSLS     r0,r0,r1
000004  4901              LDR      r1,|L25.12|
000006  6188              STR      r0,[r1,#0x18]
000008  4770              BX       lr                    ;40
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      0x40040040

                          AREA ||area_number.26||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.26||, ||.text||
                  PWM_GetPeriodIntFlag PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  4803              LDR      r0,|L26.16|
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  6980              LDR      r0,[r0,#0x18]
000004  2201              MOVS     r2,#1                 ;40
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2              ;40
00000a  d000              BEQ      |L26.14|
00000c  2001              MOVS     r0,#1
                  |L26.14|
00000e  4770              BX       lr
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;43         uint16_t u16CNR = 0xFFFF;
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
;;;56                 u8Prescale = 2;
;;;57     
;;;58             i /= u8Prescale;
;;;59     
;;;60             if(i <= 0x10000) {
;;;61                 if(i == 1)
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
;;;71     
;;;72         u8Prescale -= 1;
;;;73         u16CNR -= 1;
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
;;;95     
;;;96         return(i);
;;;97     }
;;;98     
                          ENDP

                  |L26.16|
                          DCD      0x40040040

;*** Start embedded assembler ***

#line 1 "..\\Library\\StdDriver\\src\\pwm.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_pwm_c_03ee09af____REV16|
#line 118 "..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_pwm_c_03ee09af____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_pwm_c_03ee09af____REVSH|
#line 132
|__asm___5_pwm_c_03ee09af____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
