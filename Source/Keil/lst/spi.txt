; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\spi.d --feedback=.\obj\template.fed --cpu=Cortex-M0 --apcs=interwork -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\Mini51Series\Include -I..\Library\StdDriver\inc -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include --omf_browse=.\obj\spi.crf ..\Library\StdDriver\src\spi.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SPI_Open PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  b5f8              PUSH     {r3-r7,lr}
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  9f06              LDR      r7,[sp,#0x18]
000004  4604              MOV      r4,r0                 ;43
000006  2b20              CMP      r3,#0x20
000008  d100              BNE      |L1.12|
;;;47             u32DataWidth = 0;
00000a  2300              MOVS     r3,#0
                  |L1.12|
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000c  00d8              LSLS     r0,r3,#3
00000e  4308              ORRS     r0,r0,r1
000010  4310              ORRS     r0,r0,r2
000012  6020              STR      r0,[r4,#0]
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
000014  f7fffffe          BL       CLK_GetHCLKFreq
;;;52     
;;;53         u32Div = 0xffff;
000018  4d0d              LDR      r5,|L1.80|
00001a  4606              MOV      r6,r0                 ;51
00001c  4628              MOV      r0,r5
;;;54     
;;;55         if(u32BusClock !=0 ) {
00001e  2f00              CMP      r7,#0
000020  d014              BEQ      |L1.76|
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
000022  4639              MOV      r1,r7
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       __aeabi_uidivmod
00002a  1c40              ADDS     r0,r0,#1
00002c  0840              LSRS     r0,r0,#1
00002e  1e40              SUBS     r0,r0,#1
;;;57             if(u32Div > 0xFFFF)
000030  42a8              CMP      r0,r5
000032  d900              BLS      |L1.54|
;;;58                 u32Div = 0xFFFF;
000034  4628              MOV      r0,r5
                  |L1.54|
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
000036  6861              LDR      r1,[r4,#4]
000038  0c09              LSRS     r1,r1,#16
00003a  0409              LSLS     r1,r1,#16
00003c  4301              ORRS     r1,r1,r0
                  |L1.62|
;;;60         } else
;;;61             spi->DIVIDER = 0;
00003e  6061              STR      r1,[r4,#4]
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
000040  0041              LSLS     r1,r0,#1
000042  1c89              ADDS     r1,r1,#2
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       __aeabi_uidivmod
;;;64     }
00004a  bdf8              POP      {r3-r7,pc}
                  |L1.76|
00004c  2100              MOVS     r1,#0                 ;61
00004e  e7f6              B        |L1.62|
;;;65     
                          ENDP

                  |L1.80|
                          DCD      0x0000ffff

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.2||, ||.text||
                  SPI_Close PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  2005              MOVS     r0,#5
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  0700              LSLS     r0,r0,#28
000004  68c2              LDR      r2,[r0,#0xc]          ;43
000006  2101              MOVS     r1,#1
000008  0309              LSLS     r1,r1,#12             ;43
;;;47             u32DataWidth = 0;
00000a  430a              ORRS     r2,r2,r1
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000c  60c2              STR      r2,[r0,#0xc]
00000e  68c2              LDR      r2,[r0,#0xc]
000010  438a              BICS     r2,r2,r1
000012  60c2              STR      r2,[r0,#0xc]
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
000014  4770              BX       lr
;;;52     
;;;53         u32Div = 0xffff;
;;;54     
;;;55         if(u32BusClock !=0 ) {
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
;;;57             if(u32Div > 0xFFFF)
;;;58                 u32Div = 0xFFFF;
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
;;;60         } else
;;;61             spi->DIVIDER = 0;
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
;;;64     }
;;;65     
                          ENDP


                          AREA ||area_number.3||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.3||, ||.text||
                  SPI_ClearRxFIFO PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  6c01              LDR      r1,[r0,#0x40]
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2              ;43
000006  6401              STR      r1,[r0,#0x40]
000008  4770              BX       lr                    ;43
;;;47             u32DataWidth = 0;
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
;;;52     
;;;53         u32Div = 0xffff;
;;;54     
;;;55         if(u32BusClock !=0 ) {
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
;;;57             if(u32Div > 0xFFFF)
;;;58                 u32Div = 0xFFFF;
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
;;;60         } else
;;;61             spi->DIVIDER = 0;
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
;;;64     }
;;;65     
                          ENDP


                          AREA ||area_number.4||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.4||, ||.text||
                  SPI_ClearTxFIFO PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  6c01              LDR      r1,[r0,#0x40]
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  2202              MOVS     r2,#2
000004  4311              ORRS     r1,r1,r2              ;43
000006  6401              STR      r1,[r0,#0x40]
000008  4770              BX       lr                    ;43
;;;47             u32DataWidth = 0;
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
;;;52     
;;;53         u32Div = 0xffff;
;;;54     
;;;55         if(u32BusClock !=0 ) {
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
;;;57             if(u32Div > 0xFFFF)
;;;58                 u32Div = 0xFFFF;
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
;;;60         } else
;;;61             spi->DIVIDER = 0;
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
;;;64     }
;;;65     
                          ENDP


                          AREA ||area_number.5||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.5||, ||.text||
                  SPI_DisableAutoSS PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  6881              LDR      r1,[r0,#8]
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  2208              MOVS     r2,#8
000004  4391              BICS     r1,r1,r2              ;43
000006  6081              STR      r1,[r0,#8]
000008  4770              BX       lr                    ;43
;;;47             u32DataWidth = 0;
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
;;;52     
;;;53         u32Div = 0xffff;
;;;54     
;;;55         if(u32BusClock !=0 ) {
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
;;;57             if(u32Div > 0xFFFF)
;;;58                 u32Div = 0xFFFF;
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
;;;60         } else
;;;61             spi->DIVIDER = 0;
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
;;;64     }
;;;65     
                          ENDP


                          AREA ||area_number.6||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.6||, ||.text||
                  SPI_EnableAutoSS PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  b510              PUSH     {r4,lr}
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  6883              LDR      r3,[r0,#8]
000004  2405              MOVS     r4,#5                 ;43
000006  43a3              BICS     r3,r3,r4
000008  4311              ORRS     r1,r1,r2              ;43
;;;47             u32DataWidth = 0;
00000a  430b              ORRS     r3,r3,r1
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000c  2108              MOVS     r1,#8
00000e  430b              ORRS     r3,r3,r1
000010  6083              STR      r3,[r0,#8]
000012  bd10              POP      {r4,pc}
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
;;;52     
;;;53         u32Div = 0xffff;
;;;54     
;;;55         if(u32BusClock !=0 ) {
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
;;;57             if(u32Div > 0xFFFF)
;;;58                 u32Div = 0xFFFF;
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
;;;60         } else
;;;61             spi->DIVIDER = 0;
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
;;;64     }
;;;65     
                          ENDP


                          AREA ||area_number.7||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.7||, ||.text||
                  SPI_SetBusClock PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  b570              PUSH     {r4-r6,lr}
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0                 ;43
000006  f7fffffe          BL       CLK_GetHCLKFreq
;;;47             u32DataWidth = 0;
00000a  4604              MOV      r4,r0
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000c  42a5              CMP      r5,r4
00000e  d900              BLS      |L7.18|
000010  4605              MOV      r5,r0
                  |L7.18|
000012  2d00              CMP      r5,#0
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
000014  d014              BEQ      |L7.64|
000016  4629              MOV      r1,r5
;;;52     
;;;53         u32Div = 0xffff;
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       __aeabi_uidivmod
;;;54     
;;;55         if(u32BusClock !=0 ) {
00001e  1c40              ADDS     r0,r0,#1
000020  0842              LSRS     r2,r0,#1
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
000022  1e52              SUBS     r2,r2,#1
000024  2aff              CMP      r2,#0xff
000026  d900              BLS      |L7.42|
000028  22ff              MOVS     r2,#0xff
                  |L7.42|
00002a  6870              LDR      r0,[r6,#4]
00002c  0a00              LSRS     r0,r0,#8
00002e  0200              LSLS     r0,r0,#8
;;;57             if(u32Div > 0xFFFF)
000030  4310              ORRS     r0,r0,r2
000032  6070              STR      r0,[r6,#4]
;;;58                 u32Div = 0xFFFF;
000034  0051              LSLS     r1,r2,#1
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
000036  1c89              ADDS     r1,r1,#2
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       __aeabi_uidivmod
;;;60         } else
;;;61             spi->DIVIDER = 0;
00003e  bd70              POP      {r4-r6,pc}
                  |L7.64|
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
000040  2000              MOVS     r0,#0
000042  bd70              POP      {r4-r6,pc}
;;;64     }
;;;65     
                          ENDP


                          AREA ||area_number.8||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.8||, ||.text||
                  SPI_EnableFIFO PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  b510              PUSH     {r4,lr}
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  6c03              LDR      r3,[r0,#0x40]
000004  2433              MOVS     r4,#0x33              ;43
000006  0624              LSLS     r4,r4,#24
000008  43a3              BICS     r3,r3,r4              ;43
;;;47             u32DataWidth = 0;
00000a  0709              LSLS     r1,r1,#28
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000c  430b              ORRS     r3,r3,r1
00000e  0611              LSLS     r1,r2,#24
000010  430b              ORRS     r3,r3,r1
000012  6403              STR      r3,[r0,#0x40]
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
000014  6801              LDR      r1,[r0,#0]
000016  2201              MOVS     r2,#1
;;;52     
;;;53         u32Div = 0xffff;
000018  0552              LSLS     r2,r2,#21
00001a  4311              ORRS     r1,r1,r2              ;51
00001c  6001              STR      r1,[r0,#0]
;;;54     
;;;55         if(u32BusClock !=0 ) {
00001e  bd10              POP      {r4,pc}
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
;;;57             if(u32Div > 0xFFFF)
;;;58                 u32Div = 0xFFFF;
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
;;;60         } else
;;;61             spi->DIVIDER = 0;
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
;;;64     }
;;;65     
                          ENDP


                          AREA ||area_number.9||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.9||, ||.text||
                  SPI_DisableFIFO PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  6801              LDR      r1,[r0,#0]
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  2201              MOVS     r2,#1
000004  0552              LSLS     r2,r2,#21             ;43
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]            ;43
;;;47             u32DataWidth = 0;
00000a  4770              BX       lr
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
;;;52     
;;;53         u32Div = 0xffff;
;;;54     
;;;55         if(u32BusClock !=0 ) {
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
;;;57             if(u32Div > 0xFFFF)
;;;58                 u32Div = 0xFFFF;
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
;;;60         } else
;;;61             spi->DIVIDER = 0;
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
;;;64     }
;;;65     
                          ENDP


                          AREA ||area_number.10||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.10||, ||.text||
                  SPI_GetBusClock PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  b510              PUSH     {r4,lr}
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  4604              MOV      r4,r0
000004  f7fffffe          BL       CLK_GetHCLKFreq
000008  6861              LDR      r1,[r4,#4]            ;43
;;;47             u32DataWidth = 0;
00000a  0840              LSRS     r0,r0,#1
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000c  b2c9              UXTB     r1,r1
00000e  1c49              ADDS     r1,r1,#1
000010  f7fffffe          BL       __aeabi_uidivmod
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
000014  bd10              POP      {r4,pc}
;;;52     
;;;53         u32Div = 0xffff;
;;;54     
;;;55         if(u32BusClock !=0 ) {
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
;;;57             if(u32Div > 0xFFFF)
;;;58                 u32Div = 0xFFFF;
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
;;;60         } else
;;;61             spi->DIVIDER = 0;
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
;;;64     }
;;;65     
                          ENDP


                          AREA ||area_number.11||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.11||, ||.text||
                  SPI_EnableInt PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  07ca              LSLS     r2,r1,#31
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  d004              BEQ      |L11.14|
000004  6802              LDR      r2,[r0,#0]            ;43
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17             ;43
;;;47             u32DataWidth = 0;
00000a  431a              ORRS     r2,r2,r3
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000c  6002              STR      r2,[r0,#0]
                  |L11.14|
00000e  074a              LSLS     r2,r1,#29
000010  d504              BPL      |L11.28|
000012  6bc2              LDR      r2,[r0,#0x3c]
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
;;;52     
;;;53         u32Div = 0xffff;
000018  431a              ORRS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]         ;51
                  |L11.28|
00001c  070a              LSLS     r2,r1,#28
;;;54     
;;;55         if(u32BusClock !=0 ) {
00001e  d503              BPL      |L11.40|
000020  6c02              LDR      r2,[r0,#0x40]
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
000022  2308              MOVS     r3,#8
000024  431a              ORRS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L11.40|
000028  06ca              LSLS     r2,r1,#27
00002a  d503              BPL      |L11.52|
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
;;;57             if(u32Div > 0xFFFF)
000030  431a              ORRS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L11.52|
;;;58                 u32Div = 0xFFFF;
000034  068a              LSLS     r2,r1,#26
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
000036  d503              BPL      |L11.64|
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  431a              ORRS     r2,r2,r3
;;;60         } else
;;;61             spi->DIVIDER = 0;
00003e  6402              STR      r2,[r0,#0x40]
                  |L11.64|
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
000040  0649              LSLS     r1,r1,#25
000042  d504              BPL      |L11.78|
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
;;;64     }
00004a  4311              ORRS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]         ;61
                  |L11.78|
00004e  4770              BX       lr                    ;61
;;;65     
                          ENDP


                          AREA ||area_number.12||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.12||, ||.text||
                  SPI_DisableInt PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  07ca              LSLS     r2,r1,#31
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         uint32_t u32Pclk, u32Div;
;;;45     
;;;46         if(u32DataWidth == 32)
000002  d004              BEQ      |L12.14|
000004  6802              LDR      r2,[r0,#0]            ;43
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17             ;43
;;;47             u32DataWidth = 0;
00000a  439a              BICS     r2,r2,r3
;;;48     
;;;49         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000c  6002              STR      r2,[r0,#0]
                  |L12.14|
00000e  074a              LSLS     r2,r1,#29
000010  d504              BPL      |L12.28|
000012  6bc2              LDR      r2,[r0,#0x3c]
;;;50     
;;;51         u32Pclk = CLK_GetHCLKFreq();
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
;;;52     
;;;53         u32Div = 0xffff;
000018  439a              BICS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]         ;51
                  |L12.28|
00001c  070a              LSLS     r2,r1,#28
;;;54     
;;;55         if(u32BusClock !=0 ) {
00001e  d503              BPL      |L12.40|
000020  6c02              LDR      r2,[r0,#0x40]
;;;56             u32Div = (((u32Pclk / u32BusClock) + 1) >> 1) - 1;
000022  2308              MOVS     r3,#8
000024  439a              BICS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L12.40|
000028  06ca              LSLS     r2,r1,#27
00002a  d503              BPL      |L12.52|
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
;;;57             if(u32Div > 0xFFFF)
000030  439a              BICS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L12.52|
;;;58                 u32Div = 0xFFFF;
000034  068a              LSLS     r2,r1,#26
;;;59             spi->DIVIDER = (spi->DIVIDER & ~0xffff) | u32Div;
000036  d503              BPL      |L12.64|
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  439a              BICS     r2,r2,r3
;;;60         } else
;;;61             spi->DIVIDER = 0;
00003e  6402              STR      r2,[r0,#0x40]
                  |L12.64|
;;;62     
;;;63         return ( u32Pclk / ((u32Div+1)*2) );
000040  0649              LSLS     r1,r1,#25
000042  d504              BPL      |L12.78|
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
;;;64     }
00004a  4391              BICS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]         ;61
                  |L12.78|
00004e  4770              BX       lr                    ;61
;;;65     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Library\\StdDriver\\src\\spi.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REV16|
#line 118 "..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_spi_c_SPI_Open____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REVSH|
#line 132
|__asm___5_spi_c_SPI_Open____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
